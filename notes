kubectl run --rm -ti --generator=run-pod/va podtest --image=nginx:alpine -- sh  # Correr pod temporal 
kubectl config set-context ci-context --namespace=ci --cluster=minikube --user=minikube  # crear nuevo contexto 
kubectl config use-context ci-context  # cambiar de contexto

##LIMITS Y REQUESTS 
lIMIT == LIMITE DE MEMORIA
REQUEST == capacidad DE MEMORIA 

kubectl get nodes
kubectl describe node minikube   ## allocation de cpu 

qos pods == tipo de pod de acuerdo a su configuracion 
(guaranteed / burstable / BestEffort)
kubectl get pods $POD -o yaml | grep -i qos

#LIMITRANGE  (A nivel de namespace Y OBJETO)
Inyecta los valores al ns y todos los pods creados dentro obtendran esos valores
kubectl get limitrange 
kubectl describe limit range NOMBRE -n
kubectl get pod $POD -o yaml -n dev | grep -i limits / requests 
kubectl describe ns 

#RESOURCE QUOTA (A NIVEL DE NAMESPACE EN GENERAL LIMITA TODOS LOS RECURSOS)
kubectl describe resourcequotas -n dev NOMBRE


#PROBES (Diagnosticos a pods como health check  comando/puerto/ HTTP request)
-Livenes :  Health check 
-Readines :  Diagnostico antes de exponer el pod 
-Startup :  checar que la app este arriba 

#VARIABLES DE ENTORNO 
- env: 
- name: VAR1
  value: "valor de prueba 1"

  env > dentor del pod nos deja ver las variables de ENTORNO
  kubectl exec -ti envar-demo -- sh > entar al pod 

  --variables de referencia 
  kubectl get pods -o yaml  > ver datos del pod 

#CONFIG MAPS  (CONFIGURACIONES GLOBALES) key - value configs (data no sensible)
kubectl create configmap nginx-config --from-file=configmaps-examples/nginx.conf
kubectl get configmaps
kubectl describe configmaps nginx-config

- 2 formas de atachar el config map 
  1. a traves de un volument montado en el pod 
  2. a traves de variables de entoron 

##SECRETS  (data sensible)
kubectl create secret generic mysecret --from-file=./secret-files/test.txt
kubectl get secrets
kubectl describe secrets mysecret
kubectl delete secret mysecret
-Los archivos son decodeados en base64
echo c2VjcmV0MT1ob2xhCnNlY3JldDI9YWRpb3M= | base64 --decode

stringData lo encodea a base 64 \ data tienes que poner el valor en base 64 

##VOLUMENES (Persistent data)
- EmptyDir (crear directorio a nivel del pod | muere con el pod )
- HostPath (no depende del pod, depende del nodo)
- CloudVols (EBS y Persistent Disks)

-Persistent Volume ( encargado de aprovisionar cloud storage)
-Persistent Volume Claim ( Reclama espacio al PV)

-Reclaim ( Retain (No se elimina el PV pero ya no es accesible )
         | Recycle (Elimina contenido del PV y lo deja disponible ) 
         | Delete (Se elimina todo alv))

kubectl get pv
kubectl descrive $PV
kubectl get pvc

- Storage class (aprovisionamiento dinamico)
kubectl get sc


##RBAC USERS AND GROUPS 
- Role == define namespace vs ClusterRole == no define namespace
- RoleBinding = asignar rol a usuario mediante archivo yaml
- ClusterRoleBinding  =
- Usuarios = Crear certificados para cada usuario (kubernetes no tiene herramienta para crear users)
-

-Crear cert 
kubectl config view   =cert del cluster 
# certificate-authority: /Users/josepinon/.minikube/ca.crt

kubectl cluster-info dump | grep authorization-mode   = verificar que RBAC este habilitado

-Roles 
kubectl get roles
kubectl desribe role pod-reader -n NAMESPACE
kubectl get rolebinding

-ClusterRole == ACCESO A TODOS LOS RECURSOS DEL Cluster
kubectl get clusterroles
administrador == cluster-admin

##Service Account  (pods permissions) (RoleBinding asignado a service account)
-1 por defualt al que son asignados los pods 
kubectl get serviceaccount
kubectl get secret

- Hacer llamados a la api de kubernetes desde un pod dentro del cluster 
curl http://Kubernetes/api/v1/namespaces/default/pods --insecure

-Utilizando token para hacer request 
TOKEN = $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -H "Authorization: Bearer ${TOKEN}" https://10.96.0.1/api/v1 --insecure
# Se deben agregar los roles al sa para que tenga permisos adecuados


## INGRESS (Exponer servicios fuera del cluster)
Cluster IP 
Node Port (puerto arriba de #3000)
Load Balancer (Cloud)

- Ingress controller 
Deployment que aplica las reglas para dirigir trafico en el cluster con Ingress 
Nginx o GCP 
1) Crear controldor nginx-controller.yaml
----*** OBTENER IP DEL SERVICIO EN MINKUBE ***------
  minikube service ingress-nginx --url -n ingress-nginx

2) Crear servicio y app ingress-example.yaml
3) Crear reglas ingress-rules.yaml
4) Para trabajar con dominio agregar dominio a /etc/hosts
192.168.64.2 app1.mydomain.com
5) Crear segunda aplicacion para exponerla en 9090 app-ingress2.yaml
6) Agregar nuevas reglas a rules.
7) Reglas para cada host y path ingress-rules-host.yaml


### AWS EKS
- Instalar AWS CLI 
- Crear y configurar usuario con acceso de admin en IAM y CLI 
# aws sts get-caller-identity  -- comprobar usuario 
- Instalar eksctl (like kubectl)
# eksctl version 









